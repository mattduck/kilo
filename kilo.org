* Kilo

This is my implementation of the Kilo text editor, written by following [[https://viewsourcecode.org/snaptoken/kilo/index.html][Build
your own text editor]]. It's written as an org-mode file, as an exercise for me to
learn a bit more about C, building terminal applications, and literate
programming with org-mode.

* Compile

This just concatenates all the C snippets to ~kilo.c~, and then runs ~make~.

#+begin_src emacs-lisp :results silent
  (defun md/kilo-compile ()
    (interactive)
    (setq-local org-confirm-babel-evaluate nil)
    (org-babel-tangle nil "kilo.c" "c")
    (compile "make"))
  (md/kilo-compile)
#+end_src

* Code


** Feature test macros

There are various macros that you can define that control what features are
available to the compiler. There is more info in the [[https://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html][GNU libc
documentation]]. Some are added in step 59, to remove a warning about implicit
declaration of ~getline()~.

#+begin_src c
# define _DEFAULT_SOURCE
# define _BSD_SOURCE
# define _GNU_SOURCE
#+end_src

** Include

#+begin_src c
  #include <ctype.h>
  #include <errno.h>
  #include <stdio.h>
  #include <stdarg.h>
  #include <stdlib.h>
  #include <string.h>
  #include <sys/ioctl.h>
  #include <sys/types.h>
  #include <time.h>
  #include <termios.h>
  #include <unistd.h>
#+end_src

** Constants

Some of these macros take a parameter, similar to functions. The main advantage
of doing this is that the preprocessor replaces the template so there's no stack
or function call needed. There are downsides too: if you have a lot of macros
it can increase the binary size, and they're limited because they're not
functions - you can't return a parameter, you can't do recursion, etc.

#+begin_src c
#define KILO_VERSION "0.0.1"
#define KILO_TAB_STOP 8
#+end_src

*** Control key

In ASCII, the control character strips bits 5 and 6 from whatever key you
press. For example, ~h~ is 01101000 and ~C-h~ is 00001000

#+begin_src c
  #define CTRL_KEY(k) ((k) & 0x1F)
#+end_src

#+begin_src c
  enum editorKey {
                  ARROW_LEFT = 1000,
                  ARROW_RIGHT,
                  ARROW_UP,
                  ARROW_DOWN,
                  DEL_KEY,
                  HOME_KEY,
                  END_KEY,
                  PAGE_UP,
                  PAGE_DOWN
  };
#+end_src

** State

#+begin_src c
  typedef struct erow {
    int size;
    int rsize; // size of contents to render
    char *chars;
    char *render;
  } erow;

  struct editorConfig {
    int cx, cy;  // cursor
    int rx;  // render index, as some chars are multi-width (eg. tabs)
    int rowoff;
    int coloff;
    int screenrows;
    int screencols;
    int numrows;
    erow *row;
    char *filename;
    char statusmsg[80];
    time_t statusmsg_time;
    struct termios orig_termios;
  };

  struct editorConfig E;
#+end_src

** Append buffer

~abuf~ will store our screen updates for writing. This is preferable to calling
~write()~ directly each time, because it reduces the number of updates, avoids
screen flickering, etc.

#+begin_src c
  struct abuf {
    char *b;
    int len;
  };

  #define ABUF_INIT {NULL, 0}  // Represents an empty buffer

  void abAppend(struct abuf *ab, const char *s, int len) {
    // Get a block of memory that is the size of the current string, plus the
    // string we're appending.
    char *new = realloc(ab->b, ab->len + len);

    if (new == NULL) return;
    memcpy(&new[ab->len], s, len);  // copy "s" after the current data
    ab->b = new;
    ab->len += len;
  }

  void abFree(struct abuf *ab) {
    free(ab->b);
  }
#+end_src

** Exiting

Most C library functions that fail set the global ~errno~. ~perror()~ looks at this
and prints a descriptive message for it - for example, "inappropriate ioctl for
device".

#+begin_src c
  void die(const char *s) {
    write(STDOUT_FILENO, "\x1b[2J", 4);  // clear screen
    write(STDOUT_FILENO, "\x1b[H", 3);  // reposition cursor
    perror(s);
    exit(1);
  }
#+end_src

** Terminal

#+begin_src c
  int editorReadKey() {
    int nread;
    char c;
    // read() returns the number of bytes read
    while ((nread = read(STDIN_FILENO, &c, 1)) != 1) {
      if (nread == -1 && errno != EAGAIN) die("read");
    }

    if (c == '\x1b') {
      char seq[3];
      if (read(STDIN_FILENO, &seq[0], 1) != 1) return '\x1b';
      if (read(STDIN_FILENO, &seq[1], 1) != 1) return '\x1b';
      if (seq[0] == '[') {

        // Page up / down, which are represented by \x1b[5~ and \x1b[6~
        if (seq[1] >= '0' && seq[1] <= '9') {
          if (read(STDIN_FILENO, &seq[2], 1) != 1) return '\x1b';
          if (seq[2] == '~') {
            switch (seq[1]) {
            case '1': return HOME_KEY;
            case '3': return DEL_KEY;
            case '4': return END_KEY;
            case '5': return PAGE_UP;
            case '6': return PAGE_DOWN;
            case '7': return HOME_KEY;
            case '8': return END_KEY;
            }
          }
        } else {

          // Arrows
          switch (seq[1]) {
          case 'A': return ARROW_UP;
          case 'B': return ARROW_DOWN;
          case 'C': return ARROW_RIGHT;
          case 'D': return ARROW_LEFT;
          case 'H': return HOME_KEY;
          case 'F': return END_KEY;
          }
        }
      } else if (seq[0] == '0') {
        switch (seq[1]) {
        case 'H': return HOME_KEY;
        case 'F': return END_KEY;
        }
      }
      return '\x1b';
    } else {
      return c;
    }
  }
#+end_src

If we read an escape character, immediately read two more bytes into ~seq~. If the
reads timeout, then assume the user just pressed escape.


The "n" command below queries the terminal for status information. ~6~ asks for
the cursor position.

#+begin_src c
  int getCursorPosition (int *rows, int *cols) {
    char buf[32];
    unsigned int i = 0;
    if (write(STDOUT_FILENO, "\x1b[6n", 4) != 4) return -1;
    while (i < sizeof(buf) -1){
      if (read(STDIN_FILENO, &buf[i], 1) != 1) break;
      if (buf[i] == 'R') break;
      i++;
    }
    buf[i] = '\0';  // printf expects stings to end with a 0 byte

    if (buf[0] != '\x1b' || buf[1] != '[') return -1;

    // sscanf will parse out two integers ("%d;%d") and put them into rows/cols.
    if (sscanf(&buf[2], "%d;%d", rows, cols) != 2) return -1;

    printf("\r\n&buf[1]: '%s'\r\n", &buf[1]);
    editorReadKey();
    return -1;
  }
#+end_src

#+begin_src c
  int getWindowSize(int *rows, int *cols) {
    struct winsize ws;
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
      if (write(STDOUT_FILENO, "\x1b[999C\x1b[999B", 12) != 12) return -1;
      return getCursorPosition(rows, cols);
    } else {
      ,*cols = ws.ws_col;
      ,*rows = ws.ws_row;
      return 0;
    }
  }
#+end_src

- TIOCGWINSZ tells the terminal to return the window size. We check for 0 in the
  column value because "apparently" that's a possible outcome.

- ~C~ is cursor forward, and ~B~ is cursor down. We assume that 999 is a large
  enough value to position to the bottom right.

*** Raw mode

#+begin_src c
  struct termios orig_termios;

  void disableRawMode() {
    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &E.orig_termios) == -1) die("tcsetattr");
  }

  void enableRawMode() {
    if (tcgetattr(STDIN_FILENO, &E.orig_termios) == -1) die("tcgetatr");
    atexit(disableRawMode);

    struct termios raw = E.orig_termios;
    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
    raw.c_oflag &= ~(OPOST);
    raw.c_cflag |= ~(CS8);
    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);

    raw.c_cc[VMIN] = 0;
    raw.c_cc[VTIME] = 1;  // 100ms
    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw) == -1) die("tcsetattr");
  }
#+end_src

- TCSAFLUSH specifies when to apply the ~setattr~ change.

- ECHO is a bitflag - ~&= ~~(ECHO)~ flips the echo bit off
  (00000000000000000000000000001000). We also do this to the ICANON flag, which
  disables canonical mode, making us read one byte at a time rather than reading
  the whole line when enter is pressed.

  IEXTEN controls ~C-v~, and ISIG controls the ~C-c~ and ~C-z~ signals.

  IXON controls ~C-s~ and ~C-q~, and ICRNL controls a feature where ~\r~
  (character 13) is turned into a newline (character 10).

  OPOST controls some output processing. The main thing we want to disable here
  (and possibly the only thing enabled by default) is the output translation of
  ~\n~ into ~\r\n~. The terminal requires these as distinct characters to begin a
  new line.

- The CS8 line is not a flag, it's a bit mask with multiple bits. Here we set
  the character size (CS) to 8 bits per byte. This is often a default.

- ~c_lflag~ stores "local" flags, which is apparently a dumping ground for a few
  miscellaneous things. There are also ~iflag~ (input), ~oflag~ (output) and ~clfag~
  (control flags).

- ~c_cc~ stands for "control characters". VMIN sets the minimum number of bytes of
  input needed before ~read()~ can return - we use 0 so that ~read()~ will return as
  soon as there's any input to read. VTIME is the timeout value in 10ths of a
  second.
** Row operations

The "render" string here contains the displayed version of each character - it
allows us to translate a tab or other control character into the value that
actually gets displayed.

#+begin_src c
  int editorRowCxToRx(erow *row, int cx) {
    int rx = 0;
    int j;
    for (j=0; j<cx; j++) {
      if (row->chars[j] == '\t')
        rx += (KILO_TAB_STOP - 1) - (rx % KILO_TAB_STOP);
      rx++;
    }
    return rx;
  }

  void editorUpdateRow(erow *row) {
    int tabs = 0;
    int j;
    for (j = 0; j < row->size; j++) {
      if (row->chars[j] == '\t') tabs++;
    }

    free(row->render);
    row->render = malloc(row->size + tabs*(KILO_TAB_STOP - 1) + 1);

    int idx =0;
    for (j = 0; j < row->size; j++) {
      if (row->chars[j] == '\t') {
        // insert spaces until the next % 8 is hit.
        row->render[idx++] = ' ';
        while (idx % KILO_TAB_STOP != 0) row->render[idx++] = ' ';
      } else {
        // Print the character
        row->render[idx++] = row->chars[j];
      }
    }
    row->render[idx] = '\0';
    row->rsize = idx; // idx contains the number of characters we copied into row->render
  }

  void editorAppendRow(char *s, size_t len) {
    E.row = realloc(E.row, sizeof(erow) * (E.numrows + 1));

    int at = E.numrows;
    E.row[at].size = len;
    E.row[at].chars = malloc(len + 1);
    memcpy(E.row[at].chars, s, len);
    E.row[at].chars[len] = '\0';

    E.row[at].rsize = 0;
    E.row[at].render = NULL;
    editorUpdateRow(&E.row[at]);

    E.numrows++;
  }
#+end_src

** File I/O

#+begin_src c
  void editorOpen(char *filename) {
    free(E.filename);
    E.filename = strdup(filename); // copies the given string to new memory loc.
    FILE *fp = fopen(filename, "r");
    if (!fp) die("fopen");

    char *line = NULL;
    size_t linecap = 0;
    ssize_t linelen;
    while ((linelen = getline(&line, &linecap, fp)) != -1) { // iterate over lines
      while (linelen > 0 && (line[linelen -1] == '\n' || line[linelen -1] == '\r'))
        linelen--;
      editorAppendRow(line, linelen);
    }
    free(line);
    fclose(fp);
  }
#+end_src

- ~getline()~ can be used to read lines from a file when we don't know how much
  memory to allocate for each line. It allocates memory for the next line it
  reads, and sets the second argument to point to that memory. You can then feed
  it the pointer back, to try to reuse the memory next time you use ~getline()~.

- We strip out the newline and CR before copying it into erow - we know that
  every erow represents a single line of text, so we don't need to actually
  store those characters at the end.

** Output

Here, ~rowoff~ refers to the top of the screen, and we have to add ~screenrows~ to
get to the bottom:

#+begin_src c
  void editorScroll() {
    E.rx = 0;
    if (E.cy < E.numrows) {
      E.rx = editorRowCxToRx(&E.row[E.cy], E.cx);
    }

    if (E.cy < E.rowoff) { // is the cursor above the visible window?
      E.rowoff = E.cy;
    }
    if (E.cy >= E.rowoff + E.screenrows) {
      E.rowoff = E.cy - E.screenrows + 1;
    }
    if (E.rx < E.coloff) {
      E.coloff = E.rx;
    }
    if (E.rx >= E.coloff + E.screencols) {
      E.coloff = E.rx - E.screencols + 1;
    }
  }
#+end_src

#+begin_src c
  void editorDrawRows(struct abuf *ab) {
    int y;
    for (y = 0; y < E.screenrows; y++) {
      int filerow = y + E.rowoff;
      if (filerow >= E.numrows) {
        // Draw things that come after the rows
        if (E.numrows == 0 && y == E.screenrows / 3) {
          char welcome[80];
          int welcomelen = snprintf(welcome, sizeof(welcome),
                                    "Kilo editor -- version %s", KILO_VERSION);
          if (welcomelen > E.screencols) welcomelen = E.screencols;
          // Add spaces for padding to center the welcome message
          int padding = (E.screencols - welcomelen) / 2;
          if (padding) {
            abAppend(ab, "~", 1);
            padding--;
          }
          while (padding--) abAppend(ab, " ", 1);
          abAppend(ab, welcome, welcomelen);
        } else {
          abAppend(ab, "~", 1);
        }
      } else {
        // Draw the row
        int len = E.row[filerow].rsize - E.coloff;
        if (len < 0) len = 0;
        if (len > E.screencols) len = E.screencols;  // Truncate the len
        abAppend(ab, &E.row[filerow].render[E.coloff], len);
      }
      abAppend(ab, "\x1b[K", 3);  // clear the rest of the row before drawing

      abAppend(ab, "\r\n", 2);  // this means there's always an empty row at the
                                // bottom of the screen
    }
  }
#+end_src

- ~filerow~ above represents the offset row, whereas ~y~ represents the absolute
  row.

#+begin_src c
  void editorDrawStatusBar(struct abuf *ab) {
    abAppend(ab, "\x1b[7m", 4);
    char status[80], rstatus[80];
    int len = snprintf(status, sizeof(status), "%.20s - %d lines",
                       E.filename ? E.filename : "[No Name]", E.numrows);
    int rlen = snprintf(rstatus, sizeof(status), "%d/%d", E.cy + 1, E.numrows);
    if (len > E.screencols) len = E.screencols; // bounds
    abAppend(ab, status, len);
    while (len < E.screencols) {
      if (E.screencols - len == rlen) { // The starting column index to start
                                        // printing rstatus
        abAppend(ab, rstatus, rlen);
        break;
      } else {
        abAppend(ab, " ", 1);
        len++;
      }
    }
    abAppend(ab, "\x1b[m", 3);
    abAppend(ab, "\r\n", 2);
  }

  void editorDrawMessageBar(struct abuf *ab) {
    abAppend(ab, "\x1b[K", 3);
    int msglen = strlen(E.statusmsg);
    if (msglen > E.screencols) msglen = E.screencols; // bounds
    if (msglen && time(NULL) - E.statusmsg_time < 5)
      abAppend(ab, E.statusmsg, msglen);
  }
#+end_src

#+begin_src c
  void editorRefreshScreen() {
    editorScroll();

    struct abuf ab = ABUF_INIT;
    abAppend(&ab, "\x1b[?25l", 6);  // hide cursor
    abAppend(&ab, "\x1b[H", 3);  // reposition cursor
    editorDrawRows(&ab);
    editorDrawStatusBar(&ab);
    editorDrawMessageBar(&ab);

    // Move the cursor
    char buf[32];
    snprintf(buf, sizeof(buf), "\x1b[%d;%dH", (E.cy - E.rowoff) + 1, (E.rx - E.coloff) + 1);
    abAppend(&ab, buf, strlen(buf));

    abAppend(&ab, "\x1b[?25h", 6);  // show cursor
    write(STDOUT_FILENO, ab.b, ab.len);
    abFree(&ab);
  }
#+end_src

- The 4 means we're writing 4 bytes. ~\x1b~ is 27, ie. the escape
  character. Escape sequences use ESC+[ as their first two characters. ~J~ clears
  the screen. The character before J is an argument. ~2J~ means clear the entire
  screen. These are VT100 escape sequences, which are widely supported.

- the ~[H~ escape sequence moves the cursor to the position given by the
  coordinates. The +1 is to convert because the terminal uses 1-indexed values.

Below, the ~...~ takes a varying number of arguments. Between ~va_start()~ and
~va_end()~ you can use ~va_arg()~ to get the next argument. ~va_start()~ needs to know
the last argument before the variable arguments list starts, so it can know the
address of the next arguments. In our case we don't use ~va_arg()~, but instead
just pass ~ap~ to ~vsnprintf~, which can format the string with a varying number of
arguments.

#+begin_src c
  void editorSetStatusMessage(const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(E.statusmsg, sizeof(E.statusmsg), fmt, ap);
    va_end(ap);
    E.statusmsg_time = time(NULL);
  }
#+end_src

** Input

#+begin_src c
  void editorMoveCursor(int key) {
    erow *row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy]; // get current row

    switch (key) {
    case ARROW_LEFT:
      if (E.cx != 0) {
        E.cx--;
      } else if (E.cy > 0) {
          // Move to the row above
          E.cy--;
          E.cx = E.row[E.cy].size;
      }
      break;
    case ARROW_RIGHT:
      if (row && E.cx < row->size) { // limit horizontal scrolling by column width
        E.cx++;
      } else if (row && E.cx == row->size) {
        // Move to the row below
        E.cy++;
        E.cx = 0;
      }
      break;
    case ARROW_UP:
      if (E.cy != 0) {
        E.cy--;
      }
      break;
    case ARROW_DOWN:
      if (E.cy != E.numrows - 1) {  // Allow advancing past the screen, but not the file.
        E.cy++;
      }
      break;
    }

    // Limit the cursor to the end of the row. Fixes the case where
    // different rows have different widths and you move to the row above/below.
    row = (E.cy >= E.numrows) ? NULL : &E.row[E.cy];
    int rowlen = row ? row->size : 0;
    if (E.cx > rowlen) {
      E.cx = rowlen;
    }

  }
#+end_src

#+begin_src c
  void editorProcessKeypress() {
    int c = editorReadKey();
    switch (c) {
    case CTRL_KEY('q'):
      write(STDOUT_FILENO, "\x1b[2J", 4);  // clear screen
      write(STDOUT_FILENO, "\x1b[H", 3);  // reposition cursor
      exit(0);
      break;
    case HOME_KEY:
      E.cx = 0;
      break;
    case END_KEY:
      if (E.cy < E.numrows)
        E.cx = E.row[E.cy].size;  // move to end of the line
      break;
    case PAGE_UP:
    case PAGE_DOWN:
      {

        // Set cursor y position to simulate scrolling the page
        if (c == PAGE_UP) {
          E.cy = E.rowoff;
        } else if (c == PAGE_DOWN) {
          E.cy = E.rowoff + E.screenrows - 1;
          if (E.cy > E.numrows) E.cy = E.numrows; // cap to end of file
        }

        // move the cursor
        int times = E.screenrows;
        while (times--)
          editorMoveCursor(c == PAGE_UP ? ARROW_UP : ARROW_DOWN);
      }
      break;
    case ARROW_UP:
    case ARROW_DOWN:
    case ARROW_LEFT:
    case ARROW_RIGHT:
      editorMoveCursor(c);
      break;
    }
  }
#+end_src
** Main

initEditor() will initialise all the fields in the E struct:

#+begin_src c
  void initEditor () {
    E.cx = 0;  // horizontal cursor
    E.cy = 0;  // vertical cursor
    E.rx = 0;  // cursor index
    E.rowoff = 0;
    E.coloff = 0;
    E.numrows = 0;
    E.row = NULL;
    E.filename = NULL;
    E.statusmsg[0] = '\0';
    E.statusmsg_time = 0;
    if (getWindowSize(&E.screenrows, &E.screencols) == -1) die("getWindowSize");
    E.screenrows -= 2;  // For the status bar and message bar
  }
#+end_src

#+begin_src c
  int main(int argc, char *argv[]) {
    enableRawMode();
    initEditor();

    if (argc >= 2) {
      editorOpen(argv[1]);
    }

    editorSetStatusMessage("HELP: Ctrl-Q = quit");

    while (1) {
      editorRefreshScreen();
      editorProcessKeypress();
    }
    return 0;
  }
#+end_src



* Log

Notes that I'm writing as I go.

** Raw mode

By default the terminal starts in canonical/cooked mode, which captures a lot of
user input rather than passing it straight to the program. Input is only sent to
the program when you hit enter, and various keys have special terminal
behaviour, like ~C-c~ and ~C-z~.

Interestingly you can "break" your terminal by running Step 5, which sets some
termios flags, and it has to be reset by the ~reset~ trick.

Step 15 disables various flags that nowadays are usually disabled by default
(but it's still good practice to disable them to enable "raw mode").


** C-s and C-q

~C-s~ stops data from being transmitted to the terminal, and ~C-q~ resumes it. I
haven't used these before. Then can be disabled with the IXON termios flag.

** EAGAIN

EAGAIN is returned by ~read()~ on timeout in Cygwin, instead of just
returning 0. I'm not using Cygwin so I suspect it's safe to remove that part.

** VT100 escape sequences

In an escape sequence like ~\x1b[2J~, ~J~ is the function and ~2~ is an argument to
it. I hadn't thought about this before - I think I had just treated "2J" as a
whole.

The ~m~ command controls text attributes like bold (~1~), underscore (~4~), blink (~5~)
and inverted colours (~7~).

~ncurses~ uses the ~terminfo~ database to figure out the capabilities of a terminal
and what the escape sequences for that terminal are. In our case we're just
hardcoding the VT100 sequences.

*** Home and End

Home and End can have multiple representations depending on the OS, which is why
they're added in multiple places in ~editorReadyKey()~ in step 52.

** Hide the cursor when drawing

This is standard practice - the cursor might jump around the screen if we're
writing to it. This can be controlled with ~?25h~ and ~?25l~, at least in later VT
models.

** Enums

If you set the first constant in an enum (as we do in step 48), then the
remaining constants are incremented automatically.
